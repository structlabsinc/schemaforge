# SchemaForge Enterprise Use Cases

This document details three real-world scenarios demonstrating SchemaForge's capabilities in high-compliance environments. For each use case, we provide the context, input examples, CLI command, and the exact output generated by the tool.

---

## 1. Finance: Audit Compliance (DB2 z/OS)

**Context:**
A banking ledger system requires a perfect audit trail of all transactions. The organization is migrating from a standard table to a **System-Period Temporal Table** to meet regulatory requirements, while strictly adhering to legacy mainframe storage parameters (`STOGROUP`, `PRIQTY`).

### Input State (Simplified)

**Source (`v1.sql`)**: Standard table.
```sql
CREATE TABLE "general_ledger" (
    "gl_id" BIGINT GENERATED ALWAYS AS IDENTITY,
    ...
    "description" VARCHAR(200)
) IN DATABASE "fin_db"."ts_gl" USING STOGROUP "sg_fin" PRIQTY 1000;
```

**Target (`v2.sql`)**: Temporal table with history linkage.
```sql
CREATE TABLE "general_ledger" (
    ...
    "description" VARCHAR(500), -- Column expanded
    "sys_start" TIMESTAMP(12) NOT NULL GENERATED ALWAYS AS ROW BEGIN,
    "sys_end" TIMESTAMP(12) NOT NULL GENERATED ALWAYS AS ROW END,
    "trans_id" TIMESTAMP(12) GENERATED ALWAYS AS TRANSACTION START ID,
    PERIOD FOR SYSTEM_TIME ("sys_start", "sys_end")
) ... PRIQTY 2000; -- Storage increased

CREATE TABLE "general_ledger_hist" ...; -- History table created
ALTER TABLE "general_ledger" ADD VERSIONING USE HISTORY TABLE "general_ledger_hist";
```

### Execution

```bash
sf compare --source examples/finance_compliance/v1.sql \
           --target examples/finance_compliance/v2.sql \
           --dialect db2 \
           --plan
```

### Expected Output (Execution Plan)

```text
Execution Plan:
  + Create Table: general_ledger_hist
    + Column: gl_id (BIGINT)
    + Column: account_number (CHAR(20))
    + Column: transaction_date (DATE)
    + Column: amount (NUMERIC(19,4))
    + Column: currency (CHAR(3))
    + Column: description (VARCHAR(500))
    + Column: sys_start (TIMESTAMP(12))
    + Column: sys_end (TIMESTAMP(12))
    + Column: trans_id (TIMESTAMP(12))
  ~ Modify Table: general_ledger
    ~ Property Change: Priqty: 1000 -> 2000
    + Add Column: sys_start (TIMESTAMP(12))
    + Add Column: trans_id (TIMESTAMP(12))
    ~ Modify Column: description
      ~ Type: VARCHAR(200) -> VARCHAR(500)
```

---

## 2. Healthcare: HIPAA Security (PostgreSQL)

**Context:**
A healthcare provider is upgrading their patient database to enforce **Row Level Security (RLS)**. This ensures that doctors can only view records associated with their organization, a critical HIPAA compliance measure. PII (SSN) is also being migrated to an encrypted format.

### Input State

**Source (`v1.sql`)**: Open access.
```sql
CREATE TABLE patients (
    patient_id UUID PRIMARY KEY,
    ssn TEXT, -- Unprotected
    ...
);
```

**Target (`v2.sql`)**: Secured with RLS.
```sql
CREATE TABLE patients (
    ...
    ssn_encrypted BYTEA,
    org_id UUID NOT NULL
);
ALTER TABLE patients ENABLE ROW LEVEL SECURITY;

CREATE POLICY "doctor_view_policy" ON patients ... USING (org_id = current_setting('app.current_org_id')::UUID);
```

### Execution

```bash
sf compare --source examples/healthcare_hipaa/v1.sql \
           --target examples/healthcare_hipaa/v2.sql \
           --dialect postgres \
           --plan
```

### Expected Output (Execution Plan)

```text
Execution Plan:
  ~ Modify Table: patients
    ~ Property Change: Row Security: False -> True
    + Add Column: ssn_encrypted (BYTEA)
    + Add Column: org_id (UUID)
    - Drop Column: ssn
  ~ Modify Table: medical_records
    + Add Column: is_sensitive (BOOLEAN)
    ~ Modify Column: notes
      ~ Comment: None -> PHI: Contains detailed clinical notes
  + Create Policy: doctor_view_policy
  + Create Policy: admin_all_policy
```

---

## 3. SaaS: Multi-Tenant Scale (MySQL)

**Context:**
A high-growth e-commerce platform needs to partition its massive `orders` table by year to maintain performance. It also introduces a `region_id` to the `users` table to prepare for future sharding.

### Input State

**Source (`v1.sql`)**: Single huge table.
```sql
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    ...
) ENGINE=InnoDB;
```

**Target (`v2.sql`)**: Partitioned by Range.
```sql
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT,
    order_date DATETIME NOT NULL,
    PRIMARY KEY (order_id, order_date)
) ENGINE=InnoDB
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    ...
);
```

### Execution

```bash
sf compare --source examples/saas_multitenant/v1.sql \
           --target examples/saas_multitenant/v2.sql \
           --dialect mysql \
           --plan
```

### Expected Output (Execution Plan)

```text
Execution Plan:
  ~ Modify Table: USERS
    + Add Column: region_id (INT)
    + Add Index: FT_USER_EMAIL (EMAIL)
  ~ Modify Table: ORDERS
    ~ Property Change: Partition: None -> RANGE (YEAR(ORDER_DATE)) (
    PARTITION P2023 VALUES LESS THAN (2024),
    PARTITION P2024 VALUES LESS THAN (2025),
    PARTITION P2025 VALUES LESS THAN (2026),
    PARTITION P_FUTURE VALUES LESS THAN MAXVALUE
)
    + Add Column: order_date (DATETIME)
```
